- [动态规划适用性](#动态规划适用性)
- [动态规划算法设计](#动态规划算法设计)
- [动态规划 状态的定义](#动态规划-状态的定义)
- [动态规划求解](#动态规划求解)
- [背包问题9讲](#背包问题9讲)
- [算法导论chapter15 习题解答](#算法导论chapter15-习题解答)
  - [15-11 库存规划](#15-11-库存规划)
  - [15-8](#15-8)
  - [15-9 字符串拆分](#15-9-字符串拆分)
  - [矩阵链乘法](#矩阵链乘法)
  - [LCS（最长公共子序列）](#lcs最长公共子序列)
  - [15-1（有向无环图的最长简单路径）](#15-1有向无环图的最长简单路径)
  - [15-7（译码算法）](#15-7译码算法)
  - [15-2（最长回文子序列）](#15-2最长回文子序列)
  - [15-3 (双调欧几里得旅行商问题)](#15-3-双调欧几里得旅行商问题)
  - [15-4 整齐打印](#15-4-整齐打印)
  - [15-5 编辑距离](#15-5-编辑距离)
  - [15-6 公司聚会计划](#15-6-公司聚会计划)
  - [15-10 投资策略规划](#15-10-投资策略规划)
  - [15-12](#15-12)

# 动态规划适用性
要判断问题是否适合dp解决，必须满足两个条件： 最优子结构和重叠子问题是动态规划的必要条件， 比如说最短简单路径满足满足最优子结构， 最长简单路径确不满足。
重叠子问题是把时间复杂度由普通的分治法 的指数级别转化到多项式级别的关键。
dynamic programming 的programming 表示的是表格，所以动态规划算法实际上是一种填表格的算法， 根据状态定义不同，一般情况下是 一维数组或者二维数组， 通常二维表格也能够优化成一维表格，比如说最长公共子序列（LCS）。

# 动态规划算法设计
动态规划的算法设计一般有两种： 自底向上的迭代法，自顶向下的带备忘的递归算法。
动态规划算法设计包含以下三个步骤： dp状态的定义， dp状态初始化， dp function（状态转移方程）。

# 动态规划 状态的定义
dp state 的定义 有时候需要对问题进行转化方能很好的定义。
1. 比如说[LCS](#lcs最长公共子序列) 是一个可以直接定义的dp问题： F[i][j] 表示s1[i] , s2[j] 的最长公共子序列的解， 问题的解就变成求f[m][n]的值；   
2. 但是最长递增子序列不是一个可以直接对问题进行定义的一类。 无法用F[i] 表示 A[0...i]的最长递增子序列。    
我们需要把问题转化成，求以A[i]结尾的最长递增子序列，然后扫描F数组， 求最大值。   
所以dp 状态的定义为： F[i] 表示已 A[i] 结尾的最长递增子序列，最后求F[0...n]的最大值。     
3. 某些情况下，状态转移方程需要不止一个， 就是需要多种表格一起合作才能共同定义问题， 求的问题的解。    
# 动态规划求解
动态规划的核心是合理定义状态以及找到状态转移方程。     
dp求解过程，需要区分是求最优解的值，还是解状态本身，求解状态本身的话需要注意在动态规划的过程中保存解状态的信息。  

# 背包问题9讲
https://github.com/tianyicui/pack

# 算法导论chapter15 习题解答
未完全解决的：
15-7（译码算法）， 15-1（有向无环图的最长简单路径）   拓扑排序问题
## 15-11 库存规划
题意不清

## 15-8
在15-8（基于接缝裁剪的图像压缩）一题，源问题是无法直接定义为状态的：F（n）是前n行破坏度最低的值。
但是定义状态F(m,n)为以（m，n）节点为结尾的接缝的最小破坏度，就是一个可求解的dp状态。
其状态转移方程为：F(m,n)=min{f(m-1,n-1); F(m-1,n); F(m-1, n+1)}+dist(m,n)
同理，求最长递增子序列时，状态是无法直接定义的。 但是定义F(i) 以i为结尾的子序列的最大值。就是一个很好的状态，
其状态转移方程为：F(i)=max(F(j)+1| if(A[j]<=A[i]))， 初始化。F(i)=1
但是这两个问题的最后，需要排序求出f(1...n), f(i,n)的最大值然后就是最终解。
## 15-9 字符串拆分
F(i, j )=min(F(i, k )+F(k+1, j)+(j-i+1)) ....  (i<k<j);    
初始化：F(i，i)=1   
状态F(i， j)表示以i，j为首尾的字符串满足这段字符串拆分的最小代价， 此问题和矩阵链乘法最小代价相似，区别是k的选取范围被指定。字符串拆分用带备忘的递归算法要好一些。因为按照字符串长度length递增进行填表的话，会有许多无意义的循环，及在字符串（i，j）中不存在合法的K。

## 矩阵链乘法
m(i,j)=min(m(i, k)+m(k+1,j)+P[i-1]*P[k]*p[j]) ... if (i<j)  
初始化：m（i，i）=0；    
状态M(i，j)表示矩阵链i..j括号化最小代价。   
##最优二叉搜索树
e[i, j]= min{ e[i, r-1]+ e[r+1,j] + w[i ,j ] } ...... if (i<=j)
e[i, i-1 ] = q[i-1]..... 初始化
w[i, j]=P + Q （ 和)

## LCS（最长公共子序列）

C(i，j)= 0 ....  if (i=0 || j=0);   
C(i，j)= C(i-1,j-1)+1....  if (A[i]==B[j]);   
C(i，j)= max(C(i-1, j); C(i, j-1))....  if ( (A[i]！=B[j]);   

## 15-1（有向无环图的最长简单路径）
拓扑排序
## 15-7（译码算法）
需要用到拓扑排序。
## 15-2（最长回文子序列）
C[i , j ]=max{ c[i+1,j-1]+2; C[i+1, j]; C[i, j-1] }... if(i<j )
C[i , i-1]= 0 , 初始化,  C[i, i ]=1
## 15-3 (双调欧几里得旅行商问题)
是一个无法根据问题直接得到状态的dp问题，换句话说，最终结果需要遍历规划表寻找最优值。
TODO：公式是图片
## 15-4 整齐打印
m（i，j）= min{m(i , k )+ m(k+1, j )}.... (i< k<j)    
思考：   
定义   
（1）extra为行末多余空格字符个数的立方和    
（2）f[i,j] = M - j + i - SUM(lk) , i<=k<=j    
（3）令len[i,j]表示第i个单词到第j个单词可以得到的最小extra    
整齐打印问题可以分解成以下子问题
（1）若f[i,j] < 0,，则len[i,j] = MIN(len[i,k] + len[k+1,j]) , i<=k<j

（2）若f[i,j] > 0 && j==n，则len[i,j] = 0

(+)若f[i,j] > 0 && j==n，则len[i,j] = (f[i,j])^3// 自己思考

（3）若i==j，则len[i,j] = (f[i,j])^3

## 15-5 编辑距离

思考：   
（1）初始化：
s[0,0]=0    
s[i,0] = i * cost(delete)     
s[0,j] = j * cost[insert]     
（2）递推
TODO： 图片
（3）最后的操作       
c[i][j] = MIN(c[m,n], MIN(c[i,n]+cost(kill)))， 其中0<=i<m
## 15-6 公司聚会计划
思考：

树中每个结点表示一个雇员，为每个结点p增加三个域，Enthu[p]的含义：结点p表示的雇员的喜欢值。In[p]的含义：若p参加聚会，以p为根的子树能得到的最大的喜欢值。NotIn[p]的含义：若p不去参加聚会，以p为根的子树能得到的最大的喜欢值。

初始化：若p为一个叶子结点时，In[p] = Enthu[p]，NotIn[p] = 0

子问题：In[p] = Enthu[p] + SUM(NotIn[p->child])，NotIn[p] = SUM(MAX(In[p->child], NotIn[p->child]))

计算当前结点的条件是它的所以孩子结点都已经计算出结果，为了方便编程，程序中使用邻接图来表示管理关系树。

Step1：构造管理关系树G（用邻接图表示，从父到孩子的边）

Step2：对管理关系树做转置操作G2（算法导论-22.1-3-有向图的转置），即从孩子到父的边

Step3：对G2求拓扑排序，依照这个排序做DP（算法导论-22.4-5-用队列实现拓扑排序）

Step4：按照Step3的序列，依次求每个点的In[p]和NotIn[p]

Step5：管理关系树的根结点root，即拓扑序列中的最后一个点，MAX(In[root], NotIn[root])即所求的值

//注意： In[p] 和NotIn[p ]  只是记录p节点左子树的sum和。


## 15-10 投资策略规划

又是一个无法直接得到状态的dp问题


## 15-12

这是一个分组背包问题。


《背包问题九讲》
1  0/1背包
每种物品仅有一件,可以选择放或不放。
用子问题定义状态:即 F [i, v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得 的最大价值。则其状态转移方程便是:
F[i,v] = max{F[i − 1,v],F[i − 1,v − Ci] + Wi}
注意： c表示 cost 花费，就是体积， W 表示收益， 可能是worth。



1.4 空间复杂度优化，  V 递减。
1.5 初始化区别：

我们看到的求最优解的背包问题题目中,事实上有两种不太相同的问法。有的题目 要求“恰好装满背包”时的最优解,有的题目则并没有要求必须把背包装满。一种区别 这两种问法的实现方法是在初始化的时候有所不同。

如果是第一种问法,要求恰好装满背包,那么在初始化时除了 F[0] 为 0,其它 F [1..V ] 均设为 −∞,这样就可以保证最终得到的 F [V ] 是一种恰好装满背包的最优解。


如果并没有要求必须把背包装满,而是只希望价格尽量大,初始化时应该将 F [0..V ] 全部设为 0。

2  完全背包问题
dp方程1 ： F[i,v]=max{F[i−1,v−kCi]+kWi |0≤kCi ≤v}
dp方程2 ：  F[i,v] = max(F[i − 1,v],F[i,v − Ci] + Wi)


完全背包问题还可以转化为0/1背包问题， 转化方法为 Ci, Wi, —> Ci, 2Ci, 4Ci,  8Ci , 2^k * Ci;


3 多重背包问题 3.1 题目


有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用,每件耗费的 空间是 Ci,价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量,且价值总和最大。

3.3 转化为 01 背包问题
     令这些系数分别为 1,2,22 ...2k−1,Mi −2k +1,且 k 是满足 Mi −2k +1 > 0 的最大整数。例如,如果 Mi 为 13,则相应的
k = 3,这种最多取 13 件的物品应被分成系数分别为 1, 2, 4, 6 的四件 物品。



6 分组的背包问题 6.1 问题

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci,价值是 Wi。这些 物品被划分为 K 组,每组中的物品互相冲突,最多选一件。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量,且价值总和最大。

6.2 算法 这个问题变成了每组物品有若干种策略:是选择本组的某一件,还是一件都不选。

也就是说设 F [k, v] 表示前 k 组物品花费费用 v 能取得的最大权值,则有:

F[k,v]=max{F[k−1,v],F[k−1,v−Ci]+Wi |itemi∈groupk} 使用一维数组的伪代码如下:

fork ←1toK forv ←V to0

for all item i in group k
 F[v] ←max{F[v],F[v−Ci]+Wi}

这里三层循环的顺序保证了每一组内的物品最多只有一个会被添加到背包中。 另外,显然可以对每组内的物品应用2.3中的优化。
